# 栈
## 栈的基本概念:
> 栈(stack)是只允许再一端进行操作的 __线性表__ 
>
> 如图所示:
>
> ![栈的示意图](https://th.bing.com/th?id=OIP.zPrTZ62WDD-Rfvc9vQG45gHaHK&w=254&h=245&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2)
>
> 栈的基本术语:
>
> 栈顶(top) 线性表允许进行插入删除的那一端
>
> 栈底(bottom) 固定的,不允许进行插入和删除的那一端
>
> 入栈(push) 向栈中添加元素
>
> 出栈(pop) 弹出栈顶元素
>
> 观察该图发现,最先加入栈的A会被压在栈底,最后加入的Z会放在栈顶,当进行弹栈操作时,最先加入栈的A会最后弹出,最后加入栈的Z反而最先弹出,这种特性概括为 __后进先出(LIFO,last in first out)__

## 栈的基本操作:
- InitStack(& S): 初始化一个空栈
- StackEmpty(S): 判断栈是否为空
- Push(& S,& x):向栈中加入元素
- Pop(& S,& e):弹出栈顶元素,同时将弹出元素保存在变量e中
- GetTop(& S, & e):获取栈顶元素,并且保存在变量中 
- DestroyStack(& S):销毁栈,并且释放栈所占用的内存空间

## 栈的数学性质:
当n个不同元素进栈时,出栈元素不同排列的个数为
$$ C_n = \frac{1}{n+1} \binom{2n}{n} $$
## 栈的表实现
- 顺序栈
- 链栈
- 共享栈
### 顺序栈的实现
```
#include <iostream>
using namespace std;

const int N = 105;
int st[N],top = -1;

int pop() {
    if (top == -1) return -1;
    return st[top--];
}

void push(int x) {
    st[++top] = x;
}

bool StackEmpty() {
    return top == -1; 
}

int main() {
    int q;
    cin >> q;
    while (q--) {
        string op;
        int x;
        cin >> op;
        if (op == "push") {
            cin >> x;
            push(x);
        }
        else {
            int res = pop();
            cout << res << endl;
        }
    }
    return 0;
}
```
### 栈的链式存储
- 链栈优点: 不存在栈满上溢出的情况(因为链表的存储地址不是连续的)
- 一般采用单链表实现
```
typedef struct LinkNode {
    ElementType data;
    struct Linknode* next;
};
```
### 共享栈

![共享栈](https://img.picui.cn/free/2024/09/16/66e832b344d02.png)
> 初始时top0 = -1, top1 = MaxSize;
>
> 0号栈入栈时stack[++top0] = e, 1号栈入栈时stack[--top1] = e;
>
> 0号栈出栈时--top0, 1好战出栈时++top1;
