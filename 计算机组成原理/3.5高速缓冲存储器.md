## 程序局部性原理
- 时间局部性
> 某个变量在程序中被重复访问
- 空间局部性
> 数据在主存的存储位置连续
```
int sum = 0;
for (int i = 0; i < n; ++i) {
    sumt += a[i];
}
```
- 上述代码同时具有时空局部性,首先数组a的存放地址是连续的,具有空间局部性,其次再循环过程中,多次使用到了变量sum和i,具有时间局部性

## Cache工作基本原理
### 读与写
- 当CPU发出 __读__ 请求后,若访存地址在Cache中命中,则将Cache中的数据读入到CPU中,若没有在Cache中,则需要访问主存,将主存中的数据按块读入到Cache中 __(局部性原理)__,如果此时Cache已满,则需要根据替换算法进行替换。
- 当CPU发出 __写__ 请求后,则会按照 __全写法__ 和 __写回法__ 进行处理
注意:Cache和主存之间的数据调度对 __任何程序员__ 来说都是透明的

### Cache 命中率
- CPU想要访问的信息在Cache中的比例称为Cache的命中率(hit)
- 设程序运行期间访问Cache的次数为Nc,访问主存的次数为Nm,则
> h = Nc / (Nc+Nm)

- Cache-主存系统的平均访问实际为
> Ta = HTc + (1- H)Tm
## Cache和主存之间的映射方式
- 直接映射
- 全相联映射
- 组相联映射
> 主存tag位的计算 = log2(主存/主存块大小)
> 主存index位的计算 = log2(Cache/主存块大小)
> 主存offset位的计算 = log2(主存块大小)
### 直接映射
- Cache行号 = 主存块号 mod Cache总行数
![Cache和主存的地址结构示意图](https://img.picui.cn/free/2024/09/19/66ec044996a63.jpg)
- 直接映射下的访存过程:
根据访存地址的index位置找到对应的Cache行,如果该Cache行中的tag位和主存地址的tag位相同且有效位为1,则Cache访问命中,此时根据offset在对应的Cache行中存取信息,若tag位不相等或者有效位不为1,则不命中,此时CPU从主存中读取该地址的一块信息到Cache中,将有效位Valid置为1,并且Cache中的tag位设置成和主存的tag位相同的内容
![直接映射下的存取](https://img.picui.cn/free/2024/09/19/66ec06f743655.jpg)
- 例如:
有一主存-Cache层次的存储器,其主存容量为1MB,Cache容量为16KB,每块有8个字,每字32位.采用直接地址映射方式,Cache初始子块为第0块,若主存地址为35301H,且CPU访问命中Cache,则在Cache的哪一个字块中(默认按 __字节编址__)
> 题目给的条件很充分,主存容量的1MB和Cache容量的16KB指的是 __数据容量__,而每个块有8个字,每个字32bit,可以知道一个cache块有32B,从而可以得到tag的位数为log(1MB/32B) = 15,index位数为log(16KB/32B) = 9,offset = log(32B) = 5
>
> 将35301H写成2进制为 __0011 0101 0011 0000 0001__,因此index的二进制形式为 __01 0011 000__转化成十进制为152
>
>
### 全相联映射
- 主存块可以放入Cache中的任意一个位置,因此对于主存块地址来说, __没有index位而只有tag位__
- 通常每个Cache行都设置一个比较器, __比较器位数 = tag位位数__ 访问是根据tag来访问Cache行
> 由于其查找过程是一种 __按内容访问__ 的存取过程,因此时间花销和硬件花销都比较大,不适合大容量Cache

![以四路并发比较为例](https://img.picui.cn/free/2024/09/19/66ec0943d53eb.jpg)

### 组相联映射
- 直接映射和全相联映射的结合,将所有的Cache行划分成Q个组, __如果一个组中包含K个Cache行,则称为K路组相联__
> Q = 1为全相联映射
>
> Q = Cache行数为直接映射
### 组相连映射下Cache的访存过程及缺失处理
- 首先根据index位找到相应的Cache组,将该组中每个Cache行的tag位和主存地址的tag位进行比较,如果找到,则命中Cache,若都不相等或者存在相等但是Valid = 0则不命中,此时从CPU中读取数据送入该Cache组中的任意一行,标记tag并且将Valid置为1
![组相联映射(以二路组相联为例)](https://img.picui.cn/free/2024/09/19/66ec0c1a13e5e.jpg)
- 选定适当的数量,可以使得组相联映射的成本接近直接映射,但是性能仍然接近全相联映射
### 标记阵列
- Cache行有效位+tag位+脏位+替换位

- 例:
某计算机的Cache共有16行,采用二路组相联方式(即每组两块)。每个主存块的大小为32B,按字节编址,主存129号单元所在的Cache组号是多少

- 法一:
> 按字节编址,则一个主存块有32个存储单元,129号存储单元实际上是第130个存储单元,则处于130/32(向上取整) = 5个存储块,则编号为4,4%8 = 4
>
- 法二:
> 将129用二进制表示为0...10000001其中后5为为块内地址,3位为组号,则组号为4
## Cache一致性问题
- 全写法(write-through) 主存和Cache均修改
- 回写法(write-back) 只修改Cache,不修改主存,在Cache的标记阵列中设置脏位

- 写分配法(write-allocate) 更新主存,且更新Cache
- 非写分配法(not-write-allocate) 更新主存,不将主存调入Cache
### 组合
> 组合原因：使用非写分配法时，减少了对缓存的依赖，从而避免了在缓存未命中的情况下的加载开销，而全写法确保数据始终与主存保持一致，适合不频繁访问的写操作。
>
> 分配法与写回法的组合允许频繁的写操作在缓存中处理，从而减少主存的访问，提高性能。由于数据首先被加载到缓存中，后续的写操作可以直接在缓存中完成，利用了缓存的速度优势。

非写分配法与全写法组合适合写操作较少且要求一致性的场景。
写分配法与写回法组合适合频繁写入的场景，能提高性能并减少主存访问。